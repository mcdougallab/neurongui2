<!-- HTML with embedded script using Jquery and d3, including all necessary functions -->

<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src = "https://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
        <script>DECLARE_THREE_JS_HERE</script>
        <script>DECLARE_PLOTSHAPE_CODE</script>
        <style>/*STYLESHEET_HERE*/</style>
    </head>
<body>

HTML_GOES_HERE

<script type="text/javascript">
var to_update = [];
var graph_vars = [];
var browser_id = BROWSER_ID_GOES_HERE;
var graph_count = 0;

// min and max functions so large arrays don't crash
function arrayMin(arr) {
    min = arr[0];
    for (i = 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    return min;
}

function arrayMax(arr) {
    max = arr[0];
    for (i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

// send request for necessary variables at initialization
$('[data-variable]').each( function () {
    to_update.push($(this).attr('data-variable'));
});
$('[data-x-var]').each( function() {
    var x_var = $(this).attr('data-x-var');
    if (!graph_vars.includes(x_var)) { 
        graph_vars.push(x_var);
    };
})
$('[data-y-var]').each( function() {
    $.each($(this).attr('data-y-var').split(';'), function(i, yvar) {
        if (!graph_vars.includes(yvar)) {
            graph_vars.push(yvar);
        };
    })
})
_set_relevant_vars(JSON.stringify([to_update, graph_vars, browser_id]));

// update any changed variables sent from python
function update_html_variable_displays(changed, deleted) {
    $.each(changed, function(key, value) {
        $(`span[data-variable="${key}"]`).text(value);
        $(`input[data-variable="${key}"]`).val(value);
    });
    $.each(deleted, function(index, key) {
        // deleted variables. individual handling maybe?
        $(`span[data-variable="${key}"]`).text("");
        $(`input[data-variable="${key}"]`).val("");
    });
}

var _shape_plots = [];
$(function() {
    _shape_plots = [];
    // setup ShapePlots, if any
    $("div[class='shapeplot']").each(function(i, elem) {
        _shape_plots.push(new ShapePlot($(elem)));
    });
});

var window_resize_timeout;

$(window).resize(function () {
    clearTimeout(window_resize_timeout);
    // only redraw things if haven't resized in 100ms
    window_resize_timeout = setTimeout(function() {
        resize_graphs();
        // shape plots
        console.log("window resizing");
        
        for (var sp of _shape_plots) {
            sp.tc.onContainerResize();
        }        
    }, 100);
});

function resize_graphs() {
    d3.selectAll("div[class='lineplot']").each( function () {
        var x_var = $(this).attr('data-x-var');
        var y_vars = $(this).attr('data-y-var').split(';');
        var div = $(this);
        var div_id = div.attr("id");
       
        var w = div.width();
        var h = div.height();

        d3.select(this).select("svg").attr("width", w).attr("height", h); // udpate svg dimensions
        svg = d3.select(this).select("svg");

        // dealing with user-set bounds
        if (div.attr("data-xlim")) {var x_dims = div.attr("data-xlim").split(';');} else {var x_dims = div.data("x_dimensions");}
        if (div.attr("data-ylim")) {var y_dims = div.attr("data-ylim").split(';');} else {var y_dims = div.data("y_dimensions");}

        // update everything else
        var colorpick = ["steelblue", "red", "yellow", "green", "cyan"];
        var margin = 50;

        // update the axes
        var xscale = d3.scaleLinear()
            .domain([x_dims[0], x_dims[1]])
            .range([margin+10, w+10-margin/2]);
        var yscale = d3.scaleLinear()
            .domain([y_dims[0], y_dims[1]])
            .range([h-margin, margin/2]);

        var axis_x = d3.axisBottom().scale(xscale).ticks(6);
        var axis_y = d3.axisLeft().scale(yscale).ticks(10);

        svg.select(".yaxis")
            .transition().duration(0)
            .attr("transform", `translate(${margin+10},0)`)
            .call(axis_y);
        svg.select(".xaxis")
            .transition().duration(0)
            .attr("transform", `translate(0,${h-margin})`)
            .call(axis_x);

        svg.select(".xlabel")
            .attr("x", xscale(x_dims[1]-0.5*(x_dims[1]-x_dims[0])))
            .attr("y", h-margin*0.3);
        svg.select(".ylabel")
            .attr("y", yscale(y_dims[1] - 0.5*(y_dims[1]-y_dims[0])))
            .attr("transform", `rotate(-90,${margin*0.3},${yscale(y_dims[1]-0.5*(y_dims[1]-y_dims[0]))})`);

        svg.select("defs").select(`#clip_${div_id}`).select("rect")
            .attr("width", w-margin*3/2)
            .attr("height", h-margin*3/2);
        svg.select(".linewrap")
            .attr("clip-path", `url(#clip_${div_id})`);

        var index = 0;
        $.each(y_vars, function (ind, y) {
            var current_line = svg.select(".linewrap").select(`#${y.replace('.','_')}`)
            current_line
                .attr("d", d3.line()
                    .x(function(d) {return xscale(d[0]);})
                    .y(function(d) {return yscale(d[1]);}));

        })

        // redo pan/zoom functionality
        var zoom = d3.zoom()
                .extent([[0, 0], [w, h]])
                .scaleExtent([1, 8])
                .translateExtent([[-margin, -margin], [w+margin, h+margin]])
                .on("zoom", zoomed);
        
        function zoomed() {
            svg.select(".linewrap").selectAll(".line")
                .attr("transform", d3.event.transform)

            var new_xscale = d3.event.transform.rescaleX(xscale);
            var new_yscale = d3.event.transform.rescaleY(yscale);
            svg.select(".xaxis").call(axis_x.scale(new_xscale));
            svg.select(".yaxis").call(axis_y.scale(new_yscale));
        }

        svg.call(zoom.transform, d3.zoomIdentity.translate(0,0).scale(1));
        //svg.call(zoom);

    });
};

function update_graph_vectors(graph_vars, action) {
    // update graph vector plots
    // assumes that vars have only been sent if all vectors have changed or been reinitialized
    // action determines if making or updating plots
    console.log('action', action);
    //my_gv = graph_vars;
    d3.selectAll("div[class='lineplot']").each( function () {
        graph_count++;
        var id = $(this).attr('id');
        // make sure they have individual identifiers
        if (!id) {
            $(this).attr('id', `graph_${graph_count}`);
        }

        var x_var = $(this).attr('data-x-var');
        var y_vars = $(this).attr('data-y-var').split(';');

        if (y_vars.length > 5) { // warning for exceeding max #lines.  TODO: come back to this
            console.log("WARNING: more than 5 series not supported on one plot.");
        }

        // initiate empty graph placeholder
        var default_xlim = [0, 5];
        var default_ylim = [-70, 0];
        if (action =="initiate") {
            if (!$(this).attr("data-xlim")) { // default to auto if bounds are not defined
                $(this).data("x_dimensions", default_xlim);  
            }
            if (!$(this).attr("data-ylim")) { // default to auto if bounds are not defined
                $(this).data("y_dimensions", default_ylim);  
            }
            make_lineplot([], this);
        }

        else if (graph_vars[x_var].length > 0) {
            console.log(graph_vars[x_var].length);

            var x_val = graph_vars[x_var]
            var lineplot_data = {}; 
            var ymins = [];
            var ymaxs =[];

            if (action=='make') {    // make a new lineplot
                $.each(y_vars, function (ind, y) {  
                    var y_val = graph_vars[y]
                    ymins.push(arrayMin(y_val));
                    ymaxs.push(arrayMax(y_val));
                    if (x_val.length <= y_val.length) { // ensures that mapping will go smoothly
                        // TODO: is this check ^ necessary anymore? and what to do if it fails?
                        lineplot_data[y] = x_val.map((k, i) => [k, y_val[i]]);
                    }
                })

                if (!$(this).attr("data-xlim")) {
                    console.log("no x data bounds given, auto dimensions set");
                    $(this).data("x_dimensions", [arrayMin(x_val), arrayMax(x_val)]);
                }
                if (!$(this).attr("data-ylim")) {
                    console.log("no y data bounds given, auto dimensions set");
                    var ydims =  [arrayMin(ymins), arrayMax(ymaxs)];
                    var padding = Math.floor((ydims[0]-ydims[1])/10);
                    ydims[0] = ydims[0] + padding;
                    ydims[1] = ydims[1] - padding;
                    $(this).data("y_dimensions", ydims);
                }
                make_lineplot(lineplot_data, this);
            }

            else if (action=='update') {
                update_lineplot(this, x_var, y_vars, graph_vars);
            }
            // reformatted to input to lineplot
                // {"1": series1, "2": series2, "3": series3}
                // where series1 = [[x, y1], [x, y1], ...]
        }
        
    });
    _flag_browser_ready(browser_id);
};

// attach button clicks to correct python functions
$('[data-onclick]').click(function() {
    _py_function_handler(browser_id, $(this).attr('data-onclick'));
});

// behavior for all input (could specify to a certain class of inputs if needed)
$('input').keypress(function(event){
    // from https://www.mkyong.com/jquery/how-to-check-if-an-enter-key-is-pressed-with-jquery/
    var keycode = (event.keyCode ? event.keyCode : event.which);
    if (keycode == '13'){
        _update_vars(browser_id, $(this).attr('data-variable'), $(this).val())
        $(this).blur()
    }
    event.stopPropagation()
});
$('input').focusout(function() {   // also update if focus is lost on input
    _update_vars(browser_id, $(this).attr('data-variable'), $(this).val())
});
$('input:checkbox').change(function() {   // also update if focus is lost on input
    _update_vars(browser_id, $(this).attr('data-variable'), $(this).is(':checked'))
});


function make_lineplot(dat, object) {
    console.log("making lineplot");
    // plot each series using a for loop
    var colorpick = ["steelblue", "red", "yellow", "green", "cyan"];
    var div = d3.select(object);
    var div_jquery = $(object);
    var div_id = div.attr("id");
    if (div_jquery.attr("data-xlim")) {var x_dims = div_jquery.attr("data-xlim").split(';');} else {var x_dims = div_jquery.data("x_dimensions");}
    if (div_jquery.attr("data-ylim")) {var y_dims = div_jquery.attr("data-ylim").split(';');} else {var y_dims = div_jquery.data("y_dimensions");}
     
    var xlabel = $(object).attr("data-xlab");
    var ylabel = $(object).attr("data-ylab");

    var w = div_jquery.width();
    var h = div_jquery.height();
    var margin = 50;

    div.select("svg").remove();

    var svg = div.append("svg").attr("width", w).attr("height", h);

    var xscale = d3.scaleLinear()
    .domain([x_dims[0], x_dims[1]])
    .range([margin+10, w+10-margin/2]);

    var yscale = d3.scaleLinear()
    .domain([y_dims[0], y_dims[1]])
    .range([h-margin, margin/2]);

    var axis_x = d3.axisBottom().scale(xscale).ticks(6);
    var axis_y = d3.axisLeft().scale(yscale).ticks(10);

    yaxis_group = svg.append("g")
        .attr("class", "yaxis")
        .attr("transform", `translate(${margin+10},0)`)
        .call(axis_y);
    xaxis_group = svg.append("g")
        .attr("class", "xaxis")
        .attr("transform", `translate(0,${h-margin})`)
        .call(axis_x);
    if (xlabel) {svg.append("text")
        .attr("class", "xlabel")
        .attr("x", xscale(x_dims[1]-0.5*(x_dims[1]-x_dims[0])))
        .attr("y", h-margin*0.3)
        .text(xlabel)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px");}
    if (ylabel) {svg.append("text")
        .attr("class", "ylabel")
        .attr("x", 5)
        .attr("y", yscale(y_dims[1] - 0.5*(y_dims[1]-y_dims[0])))
        .attr("transform", `rotate(-90,${margin*0.3},${yscale(y_dims[1]-0.5*(y_dims[1]-y_dims[0]))})`)
        .text(ylabel)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px");}

    //legend TODO: default to variable names if no legendlabs given
    var legend_labs = $(object).attr('data-legendlabs');
    if (legend_labs) {
        legend_labs = legend_labs.split(';');
        var nleg = legend_labs.length;
        $.each(legend_labs, function(ind, lab) {
            svg.append("rect")
                .attr("x", (ind+1)*60)
                .attr("y", margin/4-8)
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", colorpick[ind])
            svg.append("text")
                .attr("x", (ind+1)*60 + 13)
                .attr("y", margin/4)
                .text(lab)
                .attr("font-size", "12px");
        })
    }

    // Add a clipPath: everything out of this area won't be drawn - for zooming
    var clip = svg.append("defs").append("svg:clipPath")
        .attr("id", `clip_${div_id}`)
        .append("svg:rect")
        .attr("width", w-margin*3/2)
        .attr("height", h-margin*3/2)
        .attr("x", margin+10)
        .attr("y", margin/2);
    var linewrap = svg.append('g')
        .attr("class", "linewrap")
        .attr("clip-path", `url(#clip_${div_id})`);


    var index = 0;
    $.each(dat, function(series_name, series_dat) {  // go through each series
        var series_color = colorpick[index];
        linewrap.append("path")
            .datum(series_dat)
            .attr("id", series_name.replace('.','_'))
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", series_color)
            .attr("stroke-width", 2)
            .attr('vector-effect', "non-scaling-stroke")
            .attr("d", d3.line()
                .x(function(d) {return xscale(d[0]);})
                .y(function(d) {return yscale(d[1]);}));

        index++;
    });

    // add pan/zoom functionality
    svg.call(d3.zoom()
            .extent([[0, 0], [w, h]])
            .scaleExtent([1, 8])
            .translateExtent([[-margin, -margin], [w+margin, h+margin]])
            .on("zoom", zoomed));
    
    function zoomed() {
        svg.select(".linewrap").selectAll(".line")
            .attr("transform", d3.event.transform)

        var new_xscale = d3.event.transform.rescaleX(xscale);
        var new_yscale = d3.event.transform.rescaleY(yscale);
        svg.select(".xaxis").call(axis_x.scale(new_xscale));
        svg.select(".yaxis").call(axis_y.scale(new_yscale));
    }
};

//function update_lineplot(new_dat, object, new_dims) {
function update_lineplot(object, x_var, y_vars, graph_vars) {
    console.log("updating lineplot");
    //----------------------------- temporary? ----------------

    var x_val = graph_vars[x_var]
    var lineplot_data = {}; 
    var ymins = [];
    var ymaxs =[];
    var svg = d3.select(object).select('svg');
    if (!$(object).attr("data-xlim")) {
        var prev_xdims = $(object).data("x_dimensions");
    }
    if (!$(object).attr("data-ylim")) {
        var prev_ydims = $(object).data("y_dimensions");
    }

    $.each(y_vars, function (ind, y) {
        var p_data = svg.select(".linewrap").select(`#${y.replace('.','_')}`).datum();
        var y_val = graph_vars[y];
        ymins.push(arrayMin(y_val));    // will this mapping work?
        ymaxs.push(arrayMax(y_val));
        if (x_val.length <= y_val.length) { // ensures that mapping will go smoothly
            // TODO: is this check ^ necessary anymore? also, better to chop off extra if it fails but still go on I think
            new_formatted_data = x_val.map((k, i) => [k, y_val[i]]);
            lineplot_data[y] = p_data.concat(new_formatted_data);
        }
    })

    if (lineplot_data) {
        min_x_val = arrayMin([arrayMin(x_val),prev_xdims[0]]);
        max_x_val = arrayMax([arrayMax(x_val),prev_xdims[1]]);
        ymins.push(prev_ydims[0]);
        ymaxs.push(prev_ydims[1]);

        if (!$(object).attr("data-xlim")) {
            $(object).data("x_dimensions", [min_x_val, max_x_val]);
            var new_xdims = [min_x_val, max_x_val];
        }
        if (!$(object).attr("data-ylim")) {
            var ydims = [arrayMin(ymins), arrayMax(ymaxs)];
            var padding = Math.floor((ydims[1]-ydims[0])/10);
            ydims[0] = ydims[0] + padding;   
            dims[1] = ydims[1] - padding;
            $(object).data("y_dimensions", ydims); 
            var new_ydims = ydims;
        }
    
        var new_dat = lineplot_data;
        //------------------------------------------------------------
        // don't delete everything; update axes and update the data for each of the paths
        var colorpick = ["steelblue", "red", "yellow", "green", "cyan"];
        var div = d3.select(object);
        var svg = div.select("svg");
        var div_jquery = $(object);
    
        var w = div_jquery.width();
        var h = div_jquery.height();
        var margin = 50;

        // update the axes
        var xscale = d3.scaleLinear()
            .domain([new_xdims[0], new_xdims[1]])
            .range([margin+10, w+10-margin/2]);

        var yscale = d3.scaleLinear()
            .domain([new_ydims[0], new_ydims[1]])
            .range([h-margin, margin/2]);

        var axis_x = d3.axisBottom().scale(xscale).ticks(6);
        var axis_y = d3.axisLeft().scale(yscale).ticks(10);

        svg.select(".yaxis")
            .transition().duration(0)
            .call(axis_y);
        svg.select(".xaxis")
            .transition().duration(0)
            .call(axis_x);

        var index = 0;
        $.each(new_dat, function(series_name, series_dat) {  // go through each series
            var series_color = colorpick[index];
            svg.select(".linewrap").select(`#${series_name.replace('.','_')}`)
                .data([series_dat])
                .attr("d", d3.line()
                    .x(function(d) {return xscale(d[0]);})
                    .y(function(d) {return yscale(d[1]);}));

            index++;
        });

        // redo pan/zoom functionality
        svg.call(d3.zoom()
                .extent([[0, 0], [w, h]])
                .scaleExtent([1, 8])
                .translateExtent([[-margin, -margin], [w+margin, h+margin]])
                .on("zoom", zoomed));

        function zoomed() {
            svg.select(".linewrap").selectAll(".line")
                .attr("transform", d3.event.transform)

            var new_xscale = d3.event.transform.rescaleX(xscale);
            var new_yscale = d3.event.transform.rescaleY(yscale);
            svg.select(".xaxis").call(axis_x.scale(new_xscale));
            svg.select(".yaxis").call(axis_y.scale(new_yscale));
        }
    }

}

</script>
</body>
</html>


