<!-- HTML with embedded script using Jquery and d3, including all necessary functions -->

<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
    </head>
<body>

HTML_GOES_HERE

<script type="text/javascript">
var to_update = [];
var graph_vars = [];
var browser_id = BROWSER_ID_GOES_HERE;

// min and max functions so large arrays don't crash
function arrayMin(arr) {
    min = arr[0];
    for (i = 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    return min;
}

function arrayMax(arr) {
    max = arr[0];
    for (i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

// send request for necessary variables at initialization
$('[data-variable]').each( function () {
    to_update.push($(this).attr('data-variable'));
});
$('[data-x-var]').each( function() {
    var x_var = $(this).attr('data-x-var');
    if (!graph_vars.includes(x_var)) { 
        graph_vars.push(x_var);
    };
})
$('[data-y-var]').each( function() {
    $.each($(this).attr('data-y-var').split(';'), function(i, yvar) {
        if (!graph_vars.includes(yvar)) {
            graph_vars.push(yvar);
        };
    })
})
_set_relevant_vars(JSON.stringify([to_update, graph_vars, browser_id]));

// update any changed variables sent from python
function update_html_variable_displays(changed, deleted) {
    $.each(changed, function(key, value) {
        $(`span[data-variable="${key}"]`).text(value);
        $(`input[data-variable="${key}"]`).val(value);
        $(`div[data-variable="${key}"][class='barplot']`).each( function() {
            make_barplot(value, this);    // send in this
        });
    });
    $.each(deleted, function(index, key) {
        // deleted variables. individual handling maybe?
        $(`span[data-variable="${key}"]`).text("");
        $(`input[data-variable="${key}"]`).val("");
    });
}

function update_graph_vectors(graph_vars, action) {
    // update graph vector plots
    // assumes that vars have only been sent if all vectors have changed or been reinitialized
    // action determines if making or updating plots
    d3.selectAll("div[class='lineplot']").each( function () {
        var id = $(this).attr('id');
        var x_var = $(this).attr('data-x-var');
        console.log(graph_vars[x_var].length);
        if (graph_vars[x_var].length > 0) {

            var y_vars = $(this).attr('data-y-var').split(';');
            var x_val = graph_vars[x_var]
            var lineplot_data = {}; 
            var ymins = [];
            var ymaxs =[];

            if (action=='make') {    // make a new lineplot
                $.each(y_vars, function (ind, y) {  
                    var y_val = graph_vars[y]
                    ymins.push(arrayMin(y_val));
                    ymaxs.push(arrayMax(y_val));
                    if (x_val.length <= y_val.length) { // ensures that mapping will go smoothly
                        // TODO: is this check ^ necessary anymore? and what to do if it fails?
                        lineplot_data[y] = x_val.map((k, i) => [k, y_val[i]]);
                    }
                })
                if (lineplot_data) {
                    var dimensions = [arrayMin(x_val), arrayMax(x_val), arrayMin(ymins), arrayMax(ymaxs)]; 
                    make_lineplot(lineplot_data, this, dimensions);
                }
            }

            else if (action=='update') {
                update_lineplot(this, x_var, y_vars, graph_vars);
            }
            // reformatted to input to lineplot
                // {"1": series1, "2": series2, "3": series3}
                // where series1 = [[x, y1], [x, y1], ...]
        }
        
    });
    _flag_browser_ready(browser_id);
};

// attach button clicks to correct python functions
$('[data-onclick]').click(function() {
    _py_function_handler(browser_id, $(this).attr('data-onclick'));
});

// behavior for all input (could specify to a certain class of inputs if needed)
$('input').keypress(function(event){
    // from https://www.mkyong.com/jquery/how-to-check-if-an-enter-key-is-pressed-with-jquery/
    var keycode = (event.keyCode ? event.keyCode : event.which);
    if (keycode == '13'){
        _update_vars(browser_id, $(this).attr('data-variable'), $(this).val())
        $(this).blur()
    }
    event.stopPropagation()
});
$('input').focusout(function() {   // also update if focus is lost on input
    _update_vars(browser_id, $(this).attr('data-variable'), $(this).val())
});

function make_barplot(dat, object) {

    var div = d3.select(object);
    // clear a previous plot
    div.select("svg").remove();

    var w = parseFloat(div.style("width").replace("px", ""));
    var h = parseFloat(div.style("height").replace("px", ""));
    var svg = div.append("svg").attr("width", w).attr("height", h);

    var xscale = d3.scaleLinear()
        .domain([0, dat.length])
        .range([0, w-(w/dat.length-5)]);

    var yscale = d3.scaleLinear()
        .domain([d3.min(dat)-1, d3.max(dat)])
        .range([h, 0]);

    var colorscale = d3.scaleLinear()
        .domain([d3.min(dat), d3.max(dat)])
        .range([0, 255]);

    svg.selectAll("rect")
        .data(dat)
        .enter()
        .append("rect")
        .attr("x", function(d, i) {
            return xscale(i);
        })
        .attr("y", function(d) {
            return yscale(d);
        })
        .attr("width", w/dat.length - 5)
        .attr("height", function(d) {
            return h-yscale(d);
        })
        .attr("fill", function(d) {
            return `rgb(0, 0, ${colorscale(d)})`;
        })

};

function make_lineplot(dat, object, dims) {
    console.log("making lineplot");
    // plot each series using a for loop
    // have a list (TODO: limitless?) to generate different colors depending on number of series to plot
    var colorpick = ["steelblue", "red", "yellow", "green"];
    var div = d3.select(object);
     
    var xlabel = $(object).attr("data-xlab");
    var ylabel = $(object).attr("data-ylab");

    var w = parseFloat(div.style("width").replace("px", ""));
    var h = parseFloat(div.style("height").replace("px", ""));
    var margin = 50;

    div.select("svg").remove();

    var svg = div.append("svg").attr("width", w).attr("height", h);
    
    //tmin, tmax, ymin, ymax = dims
    var padding = Math.floor((dims[3]-dims[2])/10);

    var xscale = d3.scaleLinear()
    .domain([dims[0], dims[1]])
    .range([margin, w-margin/2]);

    var yscale = d3.scaleLinear()
    .domain([dims[2]-padding, dims[3]+padding])
    .range([h-margin, margin/2]);

    svg.append("g")
        .attr("class", "yaxis")
        .attr("transform", `translate(${margin},0)`)
        .call(d3.axisLeft()
            .scale(yscale)
            .ticks(10));
    svg.append("g")
        .attr("class", "xaxis")
        .attr("transform", `translate(0,${h-margin})`)
        .call(d3.axisBottom()
            .scale(xscale)
            .ticks(6));
    svg.append("text")
        .attr("x", xscale(dims[1]-0.5*(dims[1]-dims[0])))
        .attr("y", h-margin*0.3)
        .text(xlabel)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px");
    svg.append("text")
        .attr("x", margin*0.3)
        .attr("y", yscale(dims[3] - 0.5*(dims[3]-dims[2])))
        .attr("transform", `rotate(-90,${margin*0.3},${yscale(dims[3]-0.5*(dims[3]-dims[2]))})`)
        .text(ylabel)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px");

    //legend TODO: default to variable names if no legendlabs given
    /*var legend_labs = $(object).attr('data-legendlabs').split(';');
    $.each(legend_labs, function(ind, lab) {
        svg.append("rect")
            .attr("x", )
            .attr("y", )
            .attr("width", 40)
            .attr("height", 40)
            .attr("fill", colorpick[ind])
        svg.append("text")
            .attr("x", )
            .attr("y", )
            .text(lab)
            .attr("font-size", "12px");
    })*/

    var index = 0;
    $.each(dat, function(series_name, series_dat) {  // go through each series
        var series_color = colorpick[index];
        svg.append("path")
            .datum(series_dat)
            .attr("id", series_name.replace('.','_'))
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", series_color)
            .attr("stroke-width", 2)
            .attr("d", d3.line()
                .x(function(d) {return xscale(d[0]);})
                .y(function(d) {return yscale(d[1]);}));

        index++;
    });
};

//function update_lineplot(new_dat, object, new_dims) {
function update_lineplot(object, x_var, y_vars, graph_vars) {
    console.log("updating lineplot");
    //----------------------------- temporary? ----------------

    var x_val = graph_vars[x_var]
    var lineplot_data = {}; 
    var ymins = [];
    var ymaxs =[];
    var svg = d3.select(object).select('svg');

    $.each(y_vars, function (ind, y) {
        var p_data = svg.select(`#${y.replace('.','_')}`).datum();//[0];
        var y_val = graph_vars[y]
        ymins.push(arrayMin(p_data.map((k, i) => k[1])));    // will this mapping work?
        ymins.push(arrayMin(y_val)); // need to compare both
        ymaxs.push(arrayMax(p_data.map((k, i) => k[1])));
        ymaxs.push(arrayMax(y_val));
        if (x_val.length <= y_val.length) { // ensures that mapping will go smoothly
            // TODO: is this check ^ necessary anymore? also, better to chop off extra if it fails but still go on I think
            new_formatted_data = x_val.map((k, i) => [k, y_val[i]]);
            lineplot_data[y] = p_data.concat(new_formatted_data);
        }
    })

    if (lineplot_data) {
        var anyseries = lineplot_data[y_vars[0]];
        // also check against previous x range
        var xmin = arrayMin(anyseries.map((k, i) => k[0]));
        var xmax = arrayMax(anyseries.map((k, i) => k[0]));
        // TODO: is it easier to do all the recalculation of dimensions just within the update_lineplot func?
        var new_dims = [xmin, xmax, arrayMin(ymins), arrayMax(ymaxs)]; 
    
        var new_dat = lineplot_data;
        //------------------------------------------------------------
        // don't delete everything; update axes and update the data for each of the paths
        var colorpick = ["steelblue", "red", "yellow", "green"];
        var div = d3.select(object);
        var svg = div.select("svg");

        var w = parseFloat(div.style("width").replace("px", ""));
        var h = parseFloat(div.style("height").replace("px", ""));
        var margin = 50;
        var padding = Math.floor((new_dims[3]-new_dims[2])/10);

        // update the axes
        var xscale = d3.scaleLinear()
            .domain([new_dims[0], new_dims[1]])
            .range([margin, w-margin/2]);

        var yscale = d3.scaleLinear()
            .domain([new_dims[2]-padding, new_dims[3]+padding])
            .range([h-margin, margin/2]);

        svg.select(".yaxis")
            .transition()
            .call(d3.axisLeft()
                .scale(yscale)
                .ticks(10));
        svg.select(".xaxis")
            .transition()
            .call(d3.axisBottom()
                .scale(xscale)
                .ticks(6));

        var index = 0;
        $.each(new_dat, function(series_name, series_dat) {  // go through each series
            var series_color = colorpick[index];
            svg.select(`#${series_name.replace('.','_')}`)
                .data([series_dat])
                .attr("d", d3.line()
                    .x(function(d) {return xscale(d[0]);})
                    .y(function(d) {return yscale(d[1]);}));

            //TODO: add legend 

            index++;
        });
    }

}

</script>
</body>
</html>


