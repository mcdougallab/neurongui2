<!-- HTML with embedded script using Jquery and d3, including all necessary functions -->

<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
    </head>
<body>

HTML_GOES_HERE

<script type="text/javascript">
var to_update = [];
var graph_vars = [];
var browser_id = BROWSER_ID_GOES_HERE;

// send request for necessary variables at initialization
$('[data-variable]').each( function () {
    to_update.push($(this).attr('data-variable'));
});
$('[data-x-var]').each( function() {
    var x_var = $(this).attr('data-x-var');
    if (!graph_vars.includes(x_var)) { 
        graph_vars.push(x_var);
    };
})
$('[data-y-var]').each( function() {
    $.each($(this).attr('data-y-var').split(';'), function(i, yvar) {
        if (!graph_vars.includes(yvar)) {
            graph_vars.push(yvar);
        };
    })
})
_set_relevant_vars(JSON.stringify([to_update, graph_vars, browser_id]));

// update any changed variables sent from python
function update_html_variable_displays(changed, deleted) {
    $.each(changed, function(key, value) {
        $(`span[data-variable="${key}"]`).text(value);
        $(`input[data-variable="${key}"]`).val(value);
        $(`div[data-variable="${key}"][class='barplot']`).each( function() {
            make_barplot(value, this);    // send in this
        });
    });
    $.each(deleted, function(index, key) {
        // deleted variables. individual handling maybe?
        $(`span[data-variable="${key}"]`).text("");
        $(`input[data-variable="${key}"]`).val("");
    });
}

function update_graph_vectors(graph_vars) {
    // update graph vector plots
    // assumes that vars have only been sent if all vectors have changed or been reinitialized
    $("div[class='lineplot']").each( function () {
        var x_var = $(this).attr('data-x-var');
        //console.log(graph_vars[x_var].length);
        if (graph_vars[x_var].length == 0) {
            make_lineplot([], this);
        }

        var y_vars = $(this).attr('data-y-var').split(';');
        var x_val = graph_vars[x_var]
        var lineplot_data = {}; 
        var ymins = [];
        var ymaxs =[];
        if (x_val.length > 0) {
            $.each(y_vars, function (ind, y) {
                var y_val = graph_vars[y]
                ymins.push(Math.min(...y_val));
                ymaxs.push(Math.max(...y_val));
                if (x_val.length <= y_val.length) { // ensures that mapping will go smoothly
                    lineplot_data[y] = x_val.map((k, i) => [k, y_val[i]]); 
                }
            })
        }
        var dimensions = [Math.min(...x_val), Math.max(...x_val), Math.min(...ymins), Math.max(...ymaxs)]; 
        if (lineplot_data) {
            make_lineplot(lineplot_data, this, dimensions);
        }
        // reformatted to input to lineplot
        // {"1": series1, "2": series2, "3": series3}
        // where series1 = [[x, y1], [x, y1], ...]
    });
};

// attach button clicks to correct python functions
$('[data-onclick]').click(function() {
    _py_function_handler(browser_id, $(this).attr('data-onclick'));
});

// behavior for all input (could specify to a certain class of inputs if needed)
$('input').keypress(function(event){
    // from https://www.mkyong.com/jquery/how-to-check-if-an-enter-key-is-pressed-with-jquery/
    var keycode = (event.keyCode ? event.keyCode : event.which);
    if (keycode == '13'){
        _update_vars(browser_id, $(this).attr('data-variable'), $(this).val())
        $(this).blur()
    }
    event.stopPropagation()
});
$('input').focusout(function() {   // also update if focus is lost on input
    _update_vars(browser_id, $(this).attr('data-variable'), $(this).val())
});

function make_barplot(dat, object) {

    var div = d3.select(object);
    // clear a previous plot
    div.select("svg").remove();

    var w = parseFloat(div.style("width").replace("px", ""));
    var h = parseFloat(div.style("height").replace("px", ""));
    var svg = div.append("svg").attr("width", w).attr("height", h);

    var xscale = d3.scaleLinear()
        .domain([0, dat.length])
        .range([0, w-(w/dat.length-5)]);

    var yscale = d3.scaleLinear()
        .domain([d3.min(dat)-1, d3.max(dat)])
        .range([h, 0]);

    var colorscale = d3.scaleLinear()
        .domain([d3.min(dat), d3.max(dat)])
        .range([0, 255]);

    svg.selectAll("rect")
        .data(dat)
        .enter()
        .append("rect")
        .attr("x", function(d, i) {
            return xscale(i);
        })
        .attr("y", function(d) {
            return yscale(d);
        })
        .attr("width", w/dat.length - 5)
        .attr("height", function(d) {
            return h-yscale(d);
        })
        .attr("fill", function(d) {
            return `rgb(0, 0, ${colorscale(d)})`;
        })

};

function make_lineplot(dat, object, dims) {
    // have a list (TODO: limitless?) to generate different colors depending on number of series to plot
    // plot each series using a for loop
    var colorpick = ["steelblue", "red", "yellow", "green"];
    var xlabel = $(object).attr("data-xlab");
    var ylabel = $(object).attr("data-ylab");

    var div = d3.select(object);
    // clear a previous plot --- CHANGE THIS
    // TODO: only clear if dat is empty; otherwise only update the lineplot data with changed values
    if (dat && dat.length == 0) {
        div.select("svg").remove();
        return;
    }
    div.select("svg").remove();

    var w = parseFloat(div.style("width").replace("px", ""));
    var h = parseFloat(div.style("height").replace("px", ""));
    var margin = 50;

    var svg = div.append("svg").attr("width", w).attr("height", h);
    
    //tmin, tmax, ymin, ymax = dims
    var padding = Math.floor((dims[3]-dims[2])/10);

    var xscale = d3.scaleLinear()
    .domain([dims[0], dims[1]])
    .range([margin, w-margin/2]);

    var yscale = d3.scaleLinear()
    .domain([dims[2]-padding, dims[3]+padding])
    .range([h-margin, margin/2]);

    svg.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(${margin},0)`)
        .call(d3.axisLeft()
            .scale(yscale));
    svg.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${h-margin})`)
        .call(d3.axisBottom()
            .scale(xscale));
    svg.append("text")
        .attr("x", xscale(dims[1]-0.5*(dims[1]-dims[0])))
        .attr("y", h-margin*0.3)
        .text(xlabel)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px");
    svg.append("text")
        .attr("x", margin*0.3)
        .attr("y", yscale(dims[3] - 0.5*(dims[3]-dims[2])))
        .attr("transform", `rotate(-90,${margin*0.3},${yscale(dims[3]-0.5*(dims[3]-dims[2]))})`)
        .text(ylabel)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px");

    var index = 0;
    $.each(dat, function(series_name, series_dat) {  // go through each series
        var series_color = colorpick[index];

        svg.append("path")
            .datum(series_dat)
            .attr("fill", "none")
            .attr("stroke", series_color)
            .attr("stroke-width", 2)
            .attr("d", d3.line()
                .x(function(d) {return xscale(d[0]);})
                .y(function(d) {return yscale(d[1]);}));

        //TODO: add legend 

        index++;
    });

};

</script>
</body>
</html>






